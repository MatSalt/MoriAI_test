 Repository 아키텍처 및 데이터 흐름 설명

  📐 아키텍처 구조

  ┌─────────────────────────────────────────────────────────────┐
  │                      FastAPI Endpoints                       │
  │                        (main.py)                             │
  └──────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
  ┌─────────────────────────────────────────────────────────────┐
  │                      BookService                             │
  │              (비즈니스 로직, TTS 연동)                         │
  └──────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
  ┌─────────────────────────────────────────────────────────────┐
  │               InMemoryBookRepository                         │
  │           (Write-Through Cache 전략)                         │
  │   ┌─────────────────────────────────────────────┐           │
  │   │         In-Memory Cache (Dict)              │           │
  │   │    { book_id: Book 객체 }                   │           │
  │   └─────────────────────────────────────────────┘           │
  └──────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
  ┌─────────────────────────────────────────────────────────────┐
  │                FileBookRepository                            │
  │              (파일 시스템 I/O 담당)                           │
  └──────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
  ┌─────────────────────────────────────────────────────────────┐
  │                   FileManager                                │
  │         (JSON 파일 저장/로드, 이미지 관리)                    │
  └──────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
                    ┌────────────────┐
                    │  File System   │
                    │  ./data/book/  │
                    │  ./data/image/ │
                    └────────────────┘

  ---
  🔄 데이터 흐름 상세 설명

  1️⃣ AbstractBookRepository (base.py)

  역할: Repository 인터페이스 정의 (추상 클래스)

  class AbstractBookRepository(ABC):
      @abstractmethod
      async def create(self, book: Book) -> Book

      @abstractmethod
      async def get(self, book_id: str) -> Optional[Book]

      @abstractmethod
      async def get_all(self) -> List[Book]

      @abstractmethod
      async def update(self, book_id: str, book: Book) -> Book

      @abstractmethod
      async def delete(self, book_id: str) -> bool

      @abstractmethod
      async def exists(self, book_id: str) -> bool

  목적:
  - 데이터 접근 로직을 추상화
  - 추후 PostgreSQL, MongoDB 등으로 교체 가능
  - 의존성 역전 원칙(DIP) 준수

  ---
  2️⃣ FileBookRepository (file_repository.py)

  역할: 파일 시스템 기반 영구 저장소

  특징:
  - ✅ 순수 파일 I/O만 담당 (캐싱 없음)
  - ✅ JSON 파일로 Book 메타데이터 저장
  - ✅ FileManager를 사용하여 실제 파일 작업 수행

  저장 구조:
  ./data/
  ├── book/
  │   ├── {book-id-1}/
  │   │   └── metadata.json    # Book 전체 데이터
  │   ├── {book-id-2}/
  │   │   └── metadata.json
  │   └── ...
  └── image/
      ├── {book-id-1}/
      │   ├── cover.png
      │   ├── {page-id-1}.png
      │   └── {page-id-2}.png
      └── ...

  주요 동작:
  # 생성
  await file_repository.create(book)
  → FileManager.save_book_metadata(book)
    → JSON 파일로 저장

  # 조회
  book = await file_repository.get(book_id)
  → FileManager.load_book_metadata(book_id)
    → JSON 파일 읽기

  # 전체 조회
  books = await file_repository.get_all()
  → FileManager.scan_all_books()
    → 모든 metadata.json 파일 스캔

  # 삭제
  await file_repository.delete(book_id)
  → FileManager.delete_book_metadata(book_id)
    → JSON 파일 삭제

  ---
  3️⃣ InMemoryBookRepository (memory_repository.py)

  역할: 인메모리 캐싱 + 파일 백업 Repository

  특징:
  - ✅ Write-Through Cache 전략 사용
  - ✅ FileBookRepository를 감싸서 캐싱 제공
  - ✅ 서버 재시작 시 자동 캐시 워밍업
  - ✅ 빠른 읽기 성능 (메모리 접근)

  캐시 구조:
  self._cache: Dict[str, Book] = {
      "book-id-1": Book(...),
      "book-id-2": Book(...),
      ...
  }

  ---
  📊 주요 동작 흐름

  CREATE (동화책 생성)

  사용자 요청
      │
      ▼
  [API] POST /storybook/create
      │
      ├─→ BookService.create_book_with_tts()
      │   ├─→ 이미지 저장 (FileManager)
      │   ├─→ TTS API 호출
      │   └─→ Book 객체 생성
      │
      ▼
  [InMemoryBookRepository] create(book)
      │
      ├─→ (1) FileBookRepository.create(book)
      │       └─→ FileManager.save_book_metadata(book)
      │           └─→ 📁 ./data/book/{book_id}/metadata.json
      │
      └─→ (2) self._cache[book.id] = book  ✅ 캐시 저장

      ✅ 결과: 파일 + 캐시 모두 저장됨

  ---
  READ (동화책 조회)

  개별 조회 (GET /storybook/books/{book_id})

  사용자 요청
      │
      ▼
  [InMemoryBookRepository] get(book_id)
      │
      ├─→ ❓ book_id in self._cache?
      │
      ├─→ YES (Cache HIT) ⚡
      │   └─→ return self._cache[book_id]
      │       └─→ 즉시 반환 (파일 I/O 없음)
      │
      └─→ NO (Cache MISS) 💾
          └─→ FileBookRepository.get(book_id)
              └─→ FileManager.load_book_metadata(book_id)
                  └─→ 📁 ./data/book/{book_id}/metadata.json 읽기
                      └─→ self._cache[book_id] = book  ✅ 캐싱
                          └─→ return book

  전체 조회 (GET /storybook/books)

  사용자 요청
      │
      ▼
  [InMemoryBookRepository] get_all()
      │
      └─→ return list(self._cache.values())  ⚡
          └─→ 캐시에서 즉시 반환 (파일 I/O 없음)

  ---
  UPDATE (동화책 수정)

  사용자 요청
      │
      ▼
  [InMemoryBookRepository] update(book_id, book)
      │
      ├─→ ❓ 존재 여부 확인
      │   └─→ book_id in cache or file?
      │
      ├─→ (1) FileBookRepository.update(book_id, book)
      │       └─→ FileManager.save_book_metadata(book)
      │           └─→ 📁 ./data/book/{book_id}/metadata.json 덮어쓰기
      │
      └─→ (2) self._cache[book_id] = book  ✅ 캐시 갱신

      ✅ 결과: 파일 + 캐시 모두 업데이트됨

  ---
  DELETE (동화책 삭제)

  사용자 요청
      │
      ▼
  [API] DELETE /storybook/books/{book_id}
      │
      ├─→ (1) InMemoryBookRepository.delete(book_id)
      │       │
      │       ├─→ FileBookRepository.delete(book_id)
      │       │   └─→ FileManager.delete_book_metadata(book_id)
      │       │       └─→ 📁 ./data/book/{book_id}/ 삭제
      │       │
      │       └─→ del self._cache[book_id]  ✅ 캐시 삭제
      │
      └─→ (2) BookService.delete_book_files(book_id)
              └─→ FileManager.delete_book_files(book_id)
                  └─→ 📁 ./data/image/{book_id}/ 삭제

      ✅ 결과: 파일 + 캐시 + 이미지 모두 삭제됨

  ---
  🚀 서버 시작 시 (Lifespan)

  @asynccontextmanager
  async def lifespan(app: FastAPI):
      # Startup
      await book_repository.initialize_cache()
          │
          ├─→ FileBookRepository.get_all()
          │   └─→ FileManager.scan_all_books()
          │       └─→ 📁 ./data/book/**/metadata.json 모두 스캔
          │
          └─→ for book in books:
                  self._cache[book.id] = book  ✅ 캐시 워밍업

      yield  # 애플리케이션 실행 중

      # Shutdown
      # (캐시는 메모리에만 있으므로 별도 정리 불필요)

  ---
  🎯 Write-Through Cache 전략

  정의: 쓰기 작업 시 캐시와 영구 저장소를 동시에 업데이트

  장점:
  - ✅ 데이터 일관성 보장: 캐시와 파일이 항상 동기화
  - ✅ 빠른 읽기: 대부분의 읽기는 캐시에서 처리 (메모리 접근)
  - ✅ 장애 복구: 서버 재시작 후 파일에서 복원 가능

  단점:
  - ⚠️ 쓰기 성능 저하: 파일 I/O가 필요하므로 느림
  - ⚠️ 메모리 사용: 모든 Book을 메모리에 저장

  ---
  📈 성능 특성

  읽기 (Read)

  - 캐시 히트: O(1) - 딕셔너리 조회 ⚡
  - 캐시 미스: O(n) - 파일 I/O 💾

  쓰기 (Write)

  - 모든 경우: O(n) - 파일 I/O 필수 💾

  서버 시작

  - 초기 로딩: O(N) - 모든 파일 스캔 💾

  ---
  🔮 추후 확장 가능성

  현재 Repository 패턴 덕분에 쉽게 교체 가능:

  # 현재: 파일 기반
  book_repository = InMemoryBookRepository(
      file_repository=FileBookRepository(...)
  )

  # 추후: PostgreSQL
  book_repository = PostgreSQLBookRepository(
      connection_string="postgresql://..."
  )

  # 추후: MongoDB
  book_repository = MongoBookRepository(
      mongo_uri="mongodb://..."
  )

  API 코드는 변경 없이 Repository만 교체하면 됩니다!

  ---
  요약

  | 구성 요소                  | 역할          | 저장소        | 속도      |
  |------------------------|-------------|------------|---------|
  | InMemoryBookRepository | 캐싱 레이어      | 메모리 (Dict) | ⚡ 매우 빠름 |
  | FileBookRepository     | 영구 저장       | 파일 시스템     | 💾 느림   |
  | FileManager            | 파일 I/O 유틸리티 | 파일 시스템     | 💾 느림   |

  핵심: Write-Through Cache 전략으로 빠른 읽기 + 데이터 영속성 모두 확보! 🎯
